{"version":3,"file":"index.js","sources":["../src/combinators/core.ts","../src/ast.ts","../src/tokens.ts","../src/combinators/string.ts","../src/combinators/json-interpolation.ts","../src/index.ts"],"sourcesContent":["import { JsonPath, Token, TokenType } from \"../tokens\";\n\nexport class JsonTemplateError extends Error {\n  jsonPath: JsonPath | undefined;\n\n  constructor(message: string, public startToken: number, public endToken: number, options?: ErrorOptions) {\n    super(message, options);\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n\n  setPath(jsonPath: JsonPath) {\n    this.jsonPath = jsonPath;\n  }\n}\n\nexport enum CoreType {\n  MatchType = \"MatchType\",\n  ManyType = \"ManyType\",\n  MaybeType = \"MaybeType\",\n}\n\nexport type CombinatorSuccessStatus<T> = {\n  success: true;\n  type: T | CoreType;\n  startToken: number;\n  endToken: number;\n};\nexport type CombinatorFailureStatus = { success: false };\nexport type CombinatorStatus<T> = CombinatorSuccessStatus<T> | CombinatorFailureStatus;\nexport type Combinator<T> = (tokens: Token[], startIdx: number) => CombinatorStatus<T>;\n\nexport const simpleFailure = (): CombinatorFailureStatus => ({ success: false });\n\nexport enum DebugLevel {\n  Trace,\n  Debug,\n  Info,\n  Warn,\n  Error,\n}\n\nconst debugStack: string[] = [];\nlet globalDebugLevel = DebugLevel.Warn;\n\nconst debugStackToString = () => {\n  // render all\n  // return debugStack.map((v, i) => (i == debugStack.length - 1 ? v : \"  \")).join(\"\");\n  return debugStack.join(\".\");\n};\n\nexport const debug = <T>(combinatorName: string, debugLevel: DebugLevel, combinator: Combinator<T>): Combinator<T> => {\n  return (tokens, startToken) => {\n    const doLog = (...any: any[]) => {\n      if (debugLevel >= globalDebugLevel) {\n        console.log(...any);\n      }\n    };\n    if (debugLevel >= globalDebugLevel) {\n      debugStack.push(combinatorName);\n    }\n    // doLog(`ENTER(${startToken}): ${debugStackToString()}`);\n    try {\n      let val = combinator(tokens, startToken);\n      if (val && val.success) {\n        doLog(`EXIT(${startToken}-${val.endToken ?? val.startToken}): ${debugStackToString()} -> SUCCESS`);\n      } else {\n        // doLog(`EXIT(${startToken}): ${debugStackToString()} -> FAILURE`);\n      }\n      return val;\n    } catch (e) {\n      doLog(`EXIT(${startToken}): ${debugStackToString()} -> ERROR`);\n      throw e;\n    } finally {\n      if (debugLevel >= globalDebugLevel) {\n        debugStack.pop();\n      }\n    }\n  };\n};\n\nexport const map = <T>(combinator: Combinator<T>, fn: (args: CombinatorStatus<T>) => CombinatorStatus<T>): Combinator<T> => {\n  return debug(\"map\", DebugLevel.Trace, (tokens, startToken): CombinatorStatus<T> => {\n    const response = combinator(tokens, startToken);\n    if (!response.success) return response;\n    return fn(response);\n  });\n};\n\nexport const sequence = <T>(\n  combinators: Combinator<T>[],\n  fn: undefined | ((args: CombinatorSuccessStatus<T>[]) => Partial<CombinatorStatus<T>>) = undefined\n): Combinator<T> => {\n  return debug(\"sequence\", DebugLevel.Trace, (tokens, startToken): CombinatorStatus<T> => {\n    let startIdx = startToken;\n    let results: CombinatorSuccessStatus<T>[] = [];\n    for (let i = 0; i < combinators.length; i++) {\n      const combinator = combinators[i];\n      let result = combinator(tokens, startIdx);\n      if (!result.success) {\n        return simpleFailure();\n      }\n\n      results.push(result);\n      startIdx = result.endToken + 1;\n    }\n\n    let response = fn !== undefined ? fn(results) : { success: true };\n    // console.log(\n    //   response.success,\n    //   response,\n    //   results.map((v) => [v.startToken, v.endToken])\n    // );\n    return response.success === false\n      ? (response as CombinatorStatus<T>)\n      : ({\n          startToken,\n          endToken: results.length > 0 ? results[results.length - 1].endToken : startToken - 1,\n          ...response,\n        } as CombinatorStatus<T>);\n  });\n};\n\nexport type OneOf<T> = Combinator<T> & { except?: (...exceptCombinators: Combinator<T>[]) => Combinator<T> };\nexport const oneOf = <T>(...combinators: Combinator<T>[]): OneOf<T> => {\n  let generateFn = (combinators: Combinator<T>[]) =>\n    debug(\"oneOf\", DebugLevel.Trace, (tokens, startToken) => {\n      let error;\n      for (let i = 0; i < combinators.length; i++) {\n        const combinator = combinators[i];\n        try {\n          let result = combinator(tokens, startToken);\n          if (result.success) {\n            return result;\n          }\n        } catch (e) {\n          if (!(e instanceof JsonTemplateError)) {\n            throw e;\n          }\n          error = e;\n        }\n      }\n\n      if (error) {\n        throw error;\n      }\n\n      return simpleFailure();\n    });\n\n  let response = generateFn(combinators) as OneOf<T>;\n  response.except = (...exceptCombinators: Combinator<T>[]) => {\n    // console.log(\"FILTERING EXCEPT\");\n    const newCombinators = combinators.filter((v) => (exceptCombinators || []).indexOf(v) === -1);\n    // console.log(`EXCEPT RETAINED ${newCombinators.length} OF ${combinators.length}`);\n    return generateFn(newCombinators);\n  };\n  return response;\n};\n\nexport const maybe = <T>(combinator: Combinator<T>): Combinator<T> => {\n  return debug(\"maybe\", DebugLevel.Trace, (tokens, startToken) => {\n    try {\n      let result = combinator(tokens, startToken);\n\n      return {\n        success: true,\n        type: CoreType.MaybeType,\n        startToken,\n        endToken: result.success ? result.endToken : startToken - 1,\n        value: result.success ? result : undefined,\n      } as CombinatorSuccessStatus<T>;\n    } catch (e) {\n      if (!(e instanceof JsonTemplateError)) {\n        throw e;\n      }\n      return {\n        success: true,\n        type: CoreType.MaybeType,\n        startToken,\n        endToken: startToken - 1,\n        value: undefined,\n      };\n    }\n  });\n};\n\nexport const many = <T>(combinator: Combinator<T>): Combinator<T> => {\n  return debug(\"many\", DebugLevel.Trace, (tokens, startToken) => {\n    let nextIdx = startToken;\n    let results: CombinatorStatus<T>[] = [];\n    while (true) {\n      let result = combinator(tokens, nextIdx);\n      if (!result.success) {\n        break;\n      }\n\n      results.push(result);\n      nextIdx = result.endToken + 1;\n    }\n\n    return {\n      success: true,\n      type: CoreType.ManyType,\n      value: results,\n      startToken,\n      endToken: results.length == 0 ? startToken - 1 : nextIdx - 1,\n      children: results,\n    } as CombinatorSuccessStatus<T>;\n  });\n};\n\nexport const match = <T>(type: TokenType): Combinator<T> => {\n  return debug(`match:${type}`, DebugLevel.Trace, (tokens, startToken): CombinatorStatus<T> => {\n    if (tokens[startToken].type != type) {\n      return simpleFailure();\n    }\n\n    return { success: true, startToken, endToken: startToken, type: CoreType.MatchType };\n  });\n};\n\nexport const required = <T>(combinator: Combinator<T>, reason: (tokens: Token[], startIdx: number) => string): Combinator<T> => {\n  return debug(\"required\", DebugLevel.Trace, (tokens, startToken) => {\n    try {\n      let result = combinator(tokens, startToken);\n      if (!result.success) {\n        throw new JsonTemplateError(reason(tokens, startToken), startToken, startToken);\n      }\n      return result;\n    } catch (e) {\n      if (e instanceof JsonTemplateError) {\n        throw new JsonTemplateError(reason(tokens, startToken), e.startToken, e.endToken, { cause: e });\n      }\n      throw e;\n    }\n  });\n};\n\ntype LaterType<T> = Combinator<T> & { init: (combinator: Combinator<T>) => void } & {\n  except?: (...exceptCombinators: Combinator<T>[]) => Combinator<T>;\n};\nexport const later = <T>(): LaterType<T> => {\n  let initCombinator: Combinator<T>;\n\n  const laterCombinator: LaterType<T> = (tokens, startToken) => {\n    if (!initCombinator) {\n      throw new Error(\"Cannot call except on uninitialized later combinator\");\n    }\n    return initCombinator(tokens, startToken);\n  };\n\n  laterCombinator.init = (combinator: Combinator<T>) => {\n    initCombinator = combinator;\n  };\n\n  laterCombinator.except = (...exceptCombinators: Combinator<T>[]) => {\n    let exceptCombinator: Combinator<T> | undefined = undefined;\n    return debug(\"later.except\", DebugLevel.Trace, (tokens, startToken) => {\n      if (!initCombinator) {\n        throw new Error(\"Cannot call except on uninitialized later combinator\");\n      }\n      if (exceptCombinator === undefined) {\n        if ((initCombinator as any)[\"except\"] === undefined) {\n          throw new Error(\"combinator does not support except\");\n        }\n        exceptCombinator = (initCombinator as LaterType<T>).except!(...exceptCombinators);\n      }\n\n      return exceptCombinator(tokens, startToken);\n    });\n  };\n\n  return laterCombinator;\n};\n","import { Combinator, JsonTemplateError } from \"./combinators/core\";\nimport { Token } from \"./tokens\";\n\nexport default class ASTBuilder<T> {\n  generateAST(tokens: Token[], rootCombinator: Combinator<T>) {\n    console.log(\"\\n\\n\");\n    try {\n      let results = rootCombinator(tokens, 0);\n      if (!results.success) {\n        throw new Error(\"Failed to parse\");\n      }\n      if (results.startToken != 0 || results.endToken != tokens.length - 1) {\n        throw new Error(\n          `Full token range not consumed: ${results.startToken} - ${results.endToken} of ${tokens.length}`\n        );\n      }\n      return results;\n    } catch (e) {\n      if (e instanceof JsonTemplateError) {\n        e.setPath(tokens[e.startToken].jsonPath);\n      }\n      throw e;\n    }\n  }\n}\n","export type Parseable =\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n  | Parseable[]\n  | { [key: string | number]: Parseable };\n\nexport enum TokenType {\n  ObjectStart = \"ObjectStart\",\n  ObjectEnd = \"ObjectEnd\",\n  ObjectEntryStart = \"ObjectEntryStart\",\n  ObjectEntryEnd = \"ObjectEntryEnd\",\n  ObjectKeyStart = \"ObjectKeyStart\",\n  ObjectKeyEnd = \"ObjectKeyEnd\",\n  ValueStart = \"ValueStart\",\n  ValueEnd = \"ValueEnd\",\n  ArrayStart = \"ArrayStart\",\n  ArrayEnd = \"ArrayEnd\",\n  ArrayEntryStart = \"ArrayEntryStart\",\n  ArrayEntryEnd = \"ArrayEntryEnd\",\n  StringLiteralStart = \"StringLiteralStart\",\n  StringCharacter = \"StringCharacter\",\n  StringLiteralEnd = \"StringLiteralEnd\",\n  NumberLiteral = \"NumberLiteral\",\n  BooleanLiteral = \"BooleanLiteral\",\n  NullLiteral = \"NullLiteral\",\n}\n\nexport type JsonPath = {\n  path: (string | number)[];\n  details?: Record<string, any>;\n};\n\nconst extendPath = (jsonPath: JsonPath, path: string | number, details?: Record<string, any>): JsonPath => {\n  return {\n    path: [...jsonPath.path, path],\n    details,\n  };\n};\n\ninterface TokenBase {\n  type: TokenType;\n  jsonPath: JsonPath;\n}\n\nexport type Token = TokenBase &\n  (\n    | {\n        type: TokenType.ObjectStart;\n      }\n    | {\n        type: TokenType.ObjectEnd;\n      }\n    | {\n        type: TokenType.ArrayStart;\n      }\n    | {\n        type: TokenType.ArrayEnd;\n      }\n    | {\n        type: TokenType.StringLiteralStart;\n      }\n    | {\n        type: TokenType.StringLiteralEnd;\n      }\n    | {\n        type: TokenType.StringCharacter;\n        value: string;\n      }\n    | {\n        type: TokenType.NumberLiteral;\n        value: number;\n      }\n    | {\n        type: TokenType.BooleanLiteral;\n        value: boolean;\n      }\n    | {\n        type: TokenType.NullLiteral;\n      }\n    | {\n        type: TokenType.ObjectEntryStart;\n      }\n    | {\n        type: TokenType.ObjectEntryEnd;\n      }\n    | {\n        type: TokenType.ObjectKeyStart;\n      }\n    | {\n        type: TokenType.ObjectKeyEnd;\n      }\n    | {\n        type: TokenType.ValueStart;\n      }\n    | {\n        type: TokenType.ValueEnd;\n      }\n    | {\n        type: TokenType.ArrayEntryStart;\n      }\n    | {\n        type: TokenType.ArrayEntryEnd;\n      }\n  );\n\nexport const TokenGenerator = {\n  objectStart: (jsonPath: JsonPath): Token => ({\n    type: TokenType.ObjectStart,\n    jsonPath,\n  }),\n  objectEnd: (jsonPath: JsonPath): Token => ({\n    type: TokenType.ObjectEnd,\n    jsonPath,\n  }),\n  arrayStart: (jsonPath: JsonPath): Token => ({\n    type: TokenType.ArrayStart,\n    jsonPath,\n  }),\n  arrayEnd: (jsonPath: JsonPath): Token => ({\n    type: TokenType.ArrayEnd,\n    jsonPath,\n  }),\n  stringLiteralStart: (jsonPath: JsonPath): Token => ({\n    type: TokenType.StringLiteralStart,\n    jsonPath,\n  }),\n  stringLiteralEnd: (jsonPath: JsonPath): Token => ({\n    type: TokenType.StringLiteralEnd,\n    jsonPath,\n  }),\n  stringCharacter: (jsonPath: JsonPath, value: string): Token => ({\n    type: TokenType.StringCharacter,\n    value,\n    jsonPath,\n  }),\n  numberLiteral: (jsonPath: JsonPath, value: number): Token => ({\n    type: TokenType.NumberLiteral,\n    value,\n    jsonPath,\n  }),\n  booleanLiteral: (jsonPath: JsonPath, value: boolean): Token => ({\n    type: TokenType.BooleanLiteral,\n    value,\n    jsonPath,\n  }),\n  nullLiteral: (jsonPath: JsonPath): Token => ({\n    type: TokenType.NullLiteral,\n    jsonPath,\n  }),\n  objectEntryStart: (jsonPath: JsonPath): Token => ({\n    type: TokenType.ObjectEntryStart,\n    jsonPath,\n  }),\n  objectEntryEnd: (jsonPath: JsonPath): Token => ({\n    type: TokenType.ObjectEntryEnd,\n    jsonPath,\n  }),\n  objectKeyStart: (jsonPath: JsonPath): Token => ({\n    type: TokenType.ObjectKeyStart,\n    jsonPath,\n  }),\n  objectKeyEnd: (jsonPath: JsonPath): Token => ({\n    type: TokenType.ObjectKeyEnd,\n    jsonPath,\n  }),\n  valueStart: (jsonPath: JsonPath): Token => ({\n    type: TokenType.ValueStart,\n    jsonPath,\n  }),\n  valueEnd: (jsonPath: JsonPath): Token => ({\n    type: TokenType.ValueEnd,\n    jsonPath,\n  }),\n  arrayEntryStart: (jsonPath: JsonPath): Token => ({\n    type: TokenType.ArrayEntryStart,\n    jsonPath,\n  }),\n  arrayEntryEnd: (jsonPath: JsonPath): Token => ({\n    type: TokenType.ArrayEntryEnd,\n    jsonPath,\n  }),\n};\n\nconst stringToTokens = (jsonPath: JsonPath, input: string): Token[] => {\n  let tokens = [];\n  const chars = Array.from(input);\n  tokens.push(TokenGenerator.stringLiteralStart(jsonPath));\n  chars.forEach((char, i) => {\n    tokens.push(TokenGenerator.stringCharacter(extendPath(jsonPath, i), char));\n  });\n  tokens.push(TokenGenerator.stringLiteralEnd(jsonPath));\n  return tokens;\n};\n\nexport class Tokenizer {\n  getValueForJsonPath(jsonPath: JsonPath, input: Parseable): [Parseable] {\n    const details = jsonPath.details || {};\n    const pathParts = jsonPath.path;\n\n    let value = input;\n\n    if (details.type === \"key\") {\n      return [pathParts[pathParts.length - 1]];\n    }\n\n    pathParts.forEach((part: string | number, i) => {\n      if (typeof part === \"number\" && Array.isArray(value)) {\n        value = value[part];\n      } else if (typeof value === \"object\") {\n        if (!value) {\n          throw new Error(`Cannot get value for jsonPath ${pathParts.slice(0, i).join(\".\")} of ${jsonPath}`);\n        }\n        value = details.type === \"key\" ? part : value[part as any]!;\n      } else if (typeof value === \"string\" && typeof part === \"number\") {\n        return value.slice(part);\n      } else {\n        throw new Error(`Error retrieving jsonPath ${pathParts.slice(0, i).join(\".\")} of ${jsonPath}`);\n      }\n    });\n    return [value];\n  }\n\n  toTokens(\n    input: Parseable,\n    tokens: Token[] | undefined = undefined,\n    _jsonPath: JsonPath | undefined = undefined\n  ): [Token[], Parseable] {\n    const jsonPath = _jsonPath || { path: [] };\n    let usedTokens = tokens || [];\n\n    if (typeof input === \"string\") {\n      let strTokens = stringToTokens(jsonPath, input);\n      usedTokens.push(...strTokens);\n    } else if (typeof input === \"number\") {\n      usedTokens.push(TokenGenerator.numberLiteral(jsonPath, input));\n    } else if (typeof input === \"boolean\") {\n      usedTokens.push(TokenGenerator.booleanLiteral(jsonPath, input));\n    } else if (input === null) {\n      usedTokens.push(TokenGenerator.nullLiteral(jsonPath));\n    } else if (Array.isArray(input)) {\n      usedTokens.push(TokenGenerator.arrayStart(jsonPath));\n      input.forEach((item, i) => {\n        usedTokens.push(TokenGenerator.arrayEntryStart(jsonPath));\n        this.toTokens(item, usedTokens, extendPath(jsonPath, i));\n        usedTokens.push(TokenGenerator.arrayEntryEnd(jsonPath));\n      });\n      usedTokens.push(TokenGenerator.arrayEnd(jsonPath));\n    } else if (typeof input === \"object\") {\n      usedTokens.push(TokenGenerator.objectStart(jsonPath));\n      Object.keys(input).forEach((key) => {\n        usedTokens.push(TokenGenerator.objectEntryStart(jsonPath));\n        usedTokens.push(TokenGenerator.objectKeyStart(jsonPath));\n        let strTokens = stringToTokens(extendPath(jsonPath, key, { type: \"key\" }), key);\n        usedTokens.push(...strTokens);\n        usedTokens.push(TokenGenerator.objectKeyEnd(jsonPath));\n        usedTokens.push(TokenGenerator.valueStart(jsonPath));\n        this.toTokens(input[key], usedTokens, extendPath(jsonPath, key, { type: \"value\" }));\n        usedTokens.push(TokenGenerator.valueEnd(jsonPath));\n        usedTokens.push(TokenGenerator.objectEntryEnd(jsonPath));\n      });\n      usedTokens.push(TokenGenerator.objectEnd(jsonPath));\n    } else {\n      throw new Error(`Unknown input type ${typeof input}`);\n    }\n\n    return [usedTokens, input];\n  }\n}\n","import { Token, TokenType } from \"../tokens\";\nimport { Combinator, DebugLevel, debug, sequence, simpleFailure } from \"./core\";\n\nexport enum StringType {\n  StringContainer = \"StringContainer\",\n  StringLiteral = \"StringLiteral\",\n  StringCharacter = \"StringCharacter\",\n  RegexpMatch = \"RegexpMatch\",\n}\n\nconst fetchNextCharsToString = (tokens: Token[], startToken: number): string | undefined => {\n  if (tokens[startToken].type != TokenType.StringCharacter) {\n    return undefined;\n  }\n\n  let strTokens = [];\n  let currToken = startToken;\n  while (currToken < tokens.length) {\n    const next = tokens[currToken];\n    if (next.type != TokenType.StringCharacter) {\n      break;\n    }\n\n    strTokens.push(next);\n    currToken++;\n  }\n\n  let matchStr = strTokens.map((v) => v.value).join(\"\");\n  return matchStr;\n};\n\nexport const specificChar = (value: string): Combinator<StringType> => {\n  return debug(\"specificChar\", DebugLevel.Trace, (tokens, startToken) => {\n    const first = tokens[startToken];\n    if (first.type != TokenType.StringCharacter || first.value != value) {\n      return simpleFailure();\n    }\n\n    return {\n      type: StringType.StringCharacter,\n      success: true,\n      value: first.value,\n      startToken,\n      endToken: startToken,\n    };\n  });\n};\n\nexport const stringUntil = (end: string): Combinator<StringType> => {\n  return debug(`stringUntil:${end}`, DebugLevel.Trace, (tokens, startToken) => {\n    let matchStr = fetchNextCharsToString(tokens, startToken);\n    if (!matchStr || matchStr.length == 0) {\n      return simpleFailure();\n    }\n\n    let endIdx = matchStr.indexOf(end);\n    if (endIdx == 0) {\n      return simpleFailure();\n    }\n\n    const matchedStr = endIdx >= 0 ? matchStr.substring(0, endIdx) : matchStr;\n    let matchChars = Array.from(matchedStr);\n    return {\n      type: StringType.StringLiteral,\n      success: true,\n      value: matchedStr,\n      startToken,\n      endToken: startToken + matchChars.length - 1,\n    };\n  });\n};\n\nexport const specificString = (value: string): Combinator<StringType> => {\n  return debug(\n    \"specificString\",\n    DebugLevel.Trace,\n    sequence(\n      Array.from(value).map((char) => specificChar(char)),\n      (chars) => {\n        return {\n          type: StringType.StringLiteral,\n          success: true,\n          startToken: chars[0].startToken,\n          endToken: chars[chars.length - 1].endToken,\n          value: (chars as any).map((v: any) => (v as any).value).join(\"\"),\n        };\n      }\n    )\n  );\n};\n\nexport const regexp = (regex: RegExp): Combinator<StringType> => {\n  return debug(\"regexp\", DebugLevel.Trace, (tokens, startToken) => {\n    const first = tokens[startToken];\n    if (first.type != TokenType.StringCharacter) {\n      return simpleFailure();\n    }\n\n    let matchStr = fetchNextCharsToString(tokens, startToken);\n    // console.log(\"MATCHING AGAINST\", matchStr);\n    if (!matchStr) {\n      return simpleFailure();\n    }\n    let match = matchStr.match(regex);\n    // console.log(\"MATCH?\", matchStr, regex, match);\n    if (!match || match.index != 0 || match.length == 0) {\n      return simpleFailure();\n    }\n\n    let matchChars = Array.from(match[0]);\n    // console.log(\"MATCHED\", match, \"FROM\", matchStr, \"REGEX\", regex);\n\n    return {\n      type: StringType.RegexpMatch,\n      success: true,\n      value: match[0],\n      startToken,\n      endToken: startToken + matchChars.length - 1,\n    };\n  });\n};\n","import { TokenType } from \"../tokens\";\nimport {\n  Combinator,\n  CoreType,\n  DebugLevel,\n  JsonTemplateError,\n  OneOf,\n  debug,\n  later,\n  many,\n  map,\n  match,\n  maybe,\n  oneOf,\n  required,\n  sequence,\n  simpleFailure,\n} from \"./core\";\nimport { StringType, regexp, specificChar, specificString, stringUntil } from \"./string\";\n\nexport const MagicJsonParams = {\n  ConvertUndefinedToNull: \"__convertUndefinedToNull\",\n};\n\nexport enum JsonInterpolatedType {\n  NumberLiteral = \"NumberLiteral\",\n  BooleanLiteral = \"BooleanLiteral\",\n  NullLiteral = \"NullLiteral\",\n  UndefinedLiteral = \"UndefinedLiteral\",\n  VariablePath = \"VariablePath\",\n  Flatten = \"Flatten\",\n  Array = \"Array\",\n  Object = \"Object\",\n  Property = \"Property\",\n  TemplateString = \"TemplateString\",\n  InterpolatedValue = \"InterpolatedValue\",\n\n  BinaryExpression = \"BinaryExpression\",\n  ConditionalStatement = \"ConditionalStatement\",\n  Condition = \"Condition\",\n  EachStatement = \"EachStatement\",\n  TernaryExpression = \"TernaryExpression\",\n  Comment = \"Comment\",\n  NullishCoalescingExpression = \"NullishCoalescingExpression\",\n  MathOperation = \"MathOperation\",\n}\n\nexport let valueType = later<JsonInterpolatedType | StringType | CoreType>();\n\nexport const whitespaceChar = oneOf(specificChar(\" \"), specificChar(\"\\t\"), specificChar(\"\\n\"), specificChar(\"\\r\"));\nexport const whitespace = debug(\"whitespace\", DebugLevel.Info, many(whitespaceChar));\n\nexport const nullStringValue = debug(\n  \"nullStringValue\",\n  DebugLevel.Info,\n  map<JsonInterpolatedType | StringType | CoreType>(specificString(\"null\"), (v) => ({\n    ...v,\n    type: JsonInterpolatedType.NullLiteral,\n    value: undefined,\n  }))\n);\nexport const undefinedStringValue = debug(\n  \"undefinedStringValue\",\n  DebugLevel.Info,\n  map<JsonInterpolatedType | StringType | CoreType>(specificString(\"undefined\"), (v) => ({\n    ...v,\n    type: JsonInterpolatedType.UndefinedLiteral,\n    value: undefined,\n  }))\n);\nexport const booleanStringValue = debug(\n  \"booleanStringValue\",\n  DebugLevel.Info,\n  map<JsonInterpolatedType | StringType | CoreType>(oneOf(specificString(\"true\"), specificString(\"false\")), (v) => {\n    return {\n      ...v,\n      type: JsonInterpolatedType.BooleanLiteral,\n      value: (v as any).value === \"true\",\n    };\n  })\n);\nexport const numberStringValue = debug(\n  \"numberStringValue\",\n  DebugLevel.Info,\n  map<JsonInterpolatedType | StringType | CoreType>(regexp(/\\-?[0-9]+(\\.[0-9]+)?/), (v) => ({\n    ...v,\n    type: JsonInterpolatedType.NumberLiteral,\n    value: (v as any).value.indexOf(\".\") !== -1 ? parseFloat((v as any).value) : parseInt((v as any).value, 10),\n  }))\n);\n\nconst variableStartRegex = /[a-zA-Z_][0-9a-zA-Z_]*\\??/;\nconst variablePathDotRegex = /\\.[0-9a-zA-Z_]+\\??/;\nconst variablePathBracketRegex = /\\[\\'?([0-9a-zA-Z_\\-:]+)\\'?\\]\\??/;\nconst childVarRegex = new RegExp(`^((${variablePathDotRegex.source})|(${variablePathBracketRegex.source}))`);\nexport const variableNameStringValue = debug(\n  \"variableNameStringValue\",\n  DebugLevel.Info,\n  map<JsonInterpolatedType | StringType | CoreType>(\n    regexp(\n      new RegExp(\n        `(${variableStartRegex.source})(((${variablePathDotRegex.source})|(${variablePathBracketRegex.source}))+)?`\n      )\n    ),\n    (v) => {\n      if ([\"true\", \"false\", \"null\", \"undefined\"].indexOf((v as any).value) !== -1) {\n        return simpleFailure();\n      }\n\n      let counter = 0;\n      let matchedPath = (v as any).value;\n      let parts = [];\n      let match = matchedPath.match(new RegExp(`${variableStartRegex.source}`));\n      if (!match || match.index !== 0) {\n        throw new Error(\"Unable to parse variable path: ${matchedPath}\");\n      }\n      parts.push(match[0]);\n      let startPos = match[0].length;\n      while (startPos < matchedPath.length) {\n        const childStr: string = matchedPath.substring(startPos);\n        match = childStr.match(childVarRegex);\n\n        if (!match || match.index !== 0) {\n          throw new Error(`Unable to parse variable path: ${childStr}`);\n        }\n\n        if (match[0].indexOf(\".\") === 0) {\n          parts.push(match[0].substring(1));\n        } else if (match[0].indexOf(\"[\") === 0) {\n          let matchedChild = match[0].substring(1, match[0].length - 1);\n          if (matchedChild.indexOf(\"'\") === 0) {\n            matchedChild = matchedChild.substring(1, matchedChild.length - 1);\n          }\n          parts.push(matchedChild);\n        } else {\n          throw new Error(`Unable to parse variable path: ${childStr}`);\n        }\n        if (match[0].length === 0) {\n          throw new Error(`Unable to parse variable path: ${childStr}`);\n        }\n        startPos += match[0].length;\n\n        if (counter++ > 20) {\n          throw new Error(\"Unable to parse variable path: too many layers deep\");\n        }\n      }\n      return {\n        ...v,\n        type: JsonInterpolatedType.VariablePath,\n        value: parts,\n      };\n    }\n  )\n);\n\nexport const stringInQuotes = debug(\n  \"stringInQuotes\",\n  DebugLevel.Info,\n  sequence<JsonInterpolatedType | StringType | CoreType>(\n    [oneOf(regexp(/\"(?:[^\"\\\\]|\\\\.)*\"/), regexp(/'(?:[^'\\\\]|\\\\.)*'/))],\n    ([match]) => {\n      return {\n        ...match,\n        type: StringType.StringLiteral,\n        value: (match as any).value.substring(1, (match as any).value.length - 1),\n      };\n    }\n  )\n);\n\nexport const spreadOperator = debug(\n  \"spreadOperator\",\n  DebugLevel.Info,\n  sequence([whitespace, specificString(\"...\"), whitespace])\n);\nexport const pipeOperator = debug(\n  \"pipeOperator\",\n  DebugLevel.Info,\n  sequence([whitespace, specificString(\"|\"), whitespace])\n);\nexport const flattenKeyword = debug(\"flattenKeyword\", DebugLevel.Info, specificString(\"flatten\"));\nexport const flattenCall = debug(\n  \"flattenCall\",\n  DebugLevel.Info,\n  sequence<JsonInterpolatedType | StringType | CoreType>(\n    [flattenKeyword, whitespace, pipeOperator],\n    ([_flattenKeyword, _whitespaceTwo, _pipeOperator]) => {\n      return {\n        type: JsonInterpolatedType.Flatten,\n        success: true,\n        startToken: _flattenKeyword.startToken,\n        endToken: _pipeOperator.endToken,\n      };\n    }\n  )\n);\n\nexport const numberLiteral: Combinator<JsonInterpolatedType> = debug(\n  \"numberLiteral\",\n  DebugLevel.Info,\n  (tokens, startToken) => {\n    const first = tokens[startToken];\n    if (first.type != TokenType.NumberLiteral) {\n      return simpleFailure();\n    }\n\n    return {\n      type: JsonInterpolatedType.NumberLiteral,\n      success: true,\n      value: first.value,\n      startToken,\n      endToken: startToken,\n    };\n  }\n);\n\nexport const booleanLiteral: Combinator<JsonInterpolatedType> = debug(\n  \"booleanLiteral\",\n  DebugLevel.Info,\n  (tokens, startToken) => {\n    const first = tokens[startToken];\n    if (first.type != TokenType.BooleanLiteral) {\n      return simpleFailure();\n    }\n\n    return {\n      type: JsonInterpolatedType.BooleanLiteral,\n      success: true,\n      value: first.value,\n      startToken,\n      endToken: startToken,\n    };\n  }\n);\n\nexport const nullLiteral: Combinator<JsonInterpolatedType> = debug(\n  \"nullLiteral\",\n  DebugLevel.Info,\n  (tokens, startToken) => {\n    const first = tokens[startToken];\n    if (first.type != TokenType.NullLiteral) {\n      return simpleFailure();\n    }\n\n    return {\n      type: JsonInterpolatedType.NullLiteral,\n      success: true,\n      startToken,\n      endToken: startToken,\n    };\n  }\n);\n\nexport const arrayEntry = debug(\n  \"arrayEntry\",\n  DebugLevel.Info,\n  sequence<JsonInterpolatedType | StringType | CoreType>(\n    [match(TokenType.ArrayEntryStart), valueType, match(TokenType.ArrayEntryEnd)],\n    ([entryStart, entryValue, entryEnd]) => ({\n      ...entryValue,\n      startToken: entryStart.startToken,\n      endToken: entryEnd.endToken,\n    })\n  )\n);\n\nexport const array = debug(\n  \"array\",\n  DebugLevel.Info,\n  sequence<JsonInterpolatedType | StringType | CoreType>(\n    [\n      match(TokenType.ArrayStart),\n      required(\n        many<JsonInterpolatedType | StringType | CoreType>(arrayEntry),\n        () => \"Arrays may only contain array entries\"\n      ),\n      required(match(TokenType.ArrayEnd), () => \"Arrays must end with an array end token\"),\n    ],\n    ([arrayStart, arrayEntries, arrayEnd]) => ({\n      type: JsonInterpolatedType.Array,\n      success: true,\n      startToken: arrayStart.startToken,\n      endToken: arrayEnd.endToken,\n      value: (arrayEntries as any).value,\n    })\n  )\n);\n\nexport const interpolatedJson = valueType;\n\nexport const expressionValueType = later<JsonInterpolatedType | CoreType | StringType>();\n\nexport const binaryExpression = later<JsonInterpolatedType | CoreType | StringType>();\nbinaryExpression.init(\n  debug(\n    \"binaryExpression\",\n    DebugLevel.Info,\n    sequence<JsonInterpolatedType | CoreType | StringType>(\n      [\n        debug(\n          \"left\",\n          DebugLevel.Info,\n          (expressionValueType as OneOf<JsonInterpolatedType | CoreType | StringType>).except!(binaryExpression)\n        ),\n        whitespace,\n        required(\n          debug(\n            \"operator\",\n            DebugLevel.Info,\n            oneOf(\n              specificString(\"===\"),\n              specificString(\"!==\"),\n              specificString(\"==\"),\n              specificString(\"!=\"),\n              specificString(\">=\"),\n              specificString(\"<=\"),\n              specificString(\">\"),\n              specificString(\"<\")\n            )\n          ),\n          () => \"Binary expressions must contain an operator\"\n        ),\n        whitespace,\n        debug(\n          \"right\",\n          DebugLevel.Info,\n          required(expressionValueType, () => \"Binary expressions must contain a right hand side\")\n        ),\n      ],\n      ([left, , operator, , right]) => {\n        return {\n          success: true,\n          type: JsonInterpolatedType.BinaryExpression,\n          operator: (operator as any).value,\n          left,\n          right,\n        };\n      }\n    )\n  )\n);\n\nexport const ifStatement = debug(\n  \"ifStatement\",\n  DebugLevel.Info,\n  sequence<JsonInterpolatedType | CoreType | StringType>(\n    [\n      specificString(\"if\"),\n      whitespace,\n      required(binaryExpression, () => \"Conditional statements must contain a binary expression\"),\n    ],\n    ([, , expression]) => {\n      return {\n        success: true,\n        type: JsonInterpolatedType.Condition,\n        conditionType: \"if\",\n        expression,\n      };\n    }\n  )\n);\nexport const ifElseStatement = debug(\n  \"ifElseStatement\",\n  DebugLevel.Info,\n  sequence<JsonInterpolatedType | CoreType | StringType>(\n    [\n      oneOf(specificString(\"ifelse\"), specificString(\"else if\")),\n      whitespace,\n      required(binaryExpression, () => \"Conditional statements must contain a binary expression\"),\n    ],\n    ([, , expression]) => {\n      return {\n        success: true,\n        type: JsonInterpolatedType.Condition,\n        conditionType: \"else if\",\n        expression,\n      };\n    }\n  )\n);\n\nexport const elseStatement = debug(\n  \"elseStatement\",\n  DebugLevel.Info,\n  sequence<JsonInterpolatedType | CoreType | StringType>([oneOf(specificString(\"else\"))], ([, ,]) => {\n    return {\n      success: true,\n      type: JsonInterpolatedType.Condition,\n      conditionType: \"else\",\n    };\n  })\n);\n\nexport const conditionalStatement = debug(\n  \"conditionalStatement\",\n  DebugLevel.Info,\n  sequence<JsonInterpolatedType | CoreType | StringType>(\n    [oneOf(ifStatement, ifElseStatement, elseStatement)],\n    ([statement]) => {\n      return {\n        success: true,\n        type: JsonInterpolatedType.ConditionalStatement,\n        statement,\n      };\n    }\n  )\n);\n\nexport const eachStatement = debug(\n  \"eachStatement\",\n  DebugLevel.Info,\n  sequence<JsonInterpolatedType | CoreType | StringType>(\n    [\n      specificString(\"each\"),\n      whitespace,\n      variableNameStringValue,\n      whitespace,\n      specificString(\"as\"),\n      whitespace,\n      variableNameStringValue,\n      whitespace,\n      maybe(ifStatement),\n    ],\n    ([_start, , from, , , , to, _, condition]) => {\n      if ((to as any).value.length !== 1) {\n        throw new Error(\"Expected a single variable name\");\n      }\n      return {\n        success: true,\n        type: JsonInterpolatedType.EachStatement,\n        from,\n        to,\n        startToken: _start.startToken,\n        endToken: condition.endToken,\n        condition: (condition as any).value ?? undefined,\n      };\n    }\n  )\n);\n\nexport const comment = debug(\n  \"comment\",\n  DebugLevel.Info,\n  sequence<JsonInterpolatedType | CoreType | StringType>([regexp(/\\/\\*.*?\\*\\//)], ([comment]) => ({\n    ...comment,\n    type: JsonInterpolatedType.Comment,\n  }))\n);\n\nexport const ternaryExpression = debug(\n  \"ternaryExpression\",\n  DebugLevel.Info,\n  sequence<JsonInterpolatedType | CoreType | StringType>(\n    [\n      required(\n        binaryExpression,\n        () => \"Ternary expressions must contain a binary expression as the first part of the expression\"\n      ),\n      whitespace,\n      required(specificString(\"?\"), () => \"Ternary expressions must contain a ? as the second part of the expression\"),\n      whitespace,\n      required(\n        expressionValueType,\n        () => \"Ternary expressions must contain a comparable value as the third part of the expression\"\n      ),\n      whitespace,\n      required(specificString(\":\"), () => \"Ternary expressions must contain a : as the fourth part of the expression\"),\n      whitespace,\n      required(\n        expressionValueType,\n        () => \"Ternary expressions must contain a comparable value as the fifth part of the expression\"\n      ),\n    ],\n    ([condition, , , , trueValue, , , , falseValue]) => {\n      return {\n        success: true,\n        type: JsonInterpolatedType.TernaryExpression,\n        condition,\n        trueValue,\n        falseValue,\n      };\n    }\n  )\n);\n\nconst nullishCoalescingExpression = later<JsonInterpolatedType | CoreType | StringType>();\nexport const parensExpression = later<JsonInterpolatedType | CoreType | StringType>();\nparensExpression.init(\n  sequence(\n    [\n      specificChar(\"(\"),\n      whitespace,\n      oneOf(\n        ternaryExpression,\n        nullishCoalescingExpression,\n        (expressionValueType as OneOf<JsonInterpolatedType | CoreType | StringType>).except!(parensExpression)\n      ),\n      whitespace,\n      specificChar(\")\"),\n    ],\n    ([_open, , expression, , _close]) => {\n      return {\n        ...expression,\n        startToken: _open.startToken,\n        endToken: _close.endToken,\n      };\n    }\n  )\n);\n\nnullishCoalescingExpression.init(\n  sequence(\n    [\n      (expressionValueType as OneOf<JsonInterpolatedType | CoreType | StringType>).except!(nullishCoalescingExpression),\n      whitespace,\n      specificString(\"??\"),\n      whitespace,\n      expressionValueType,\n    ],\n    ([left, , , , right]) => {\n      return {\n        success: true,\n        type: JsonInterpolatedType.NullishCoalescingExpression,\n        operator: \"??\",\n        left,\n        right,\n      };\n    }\n  )\n);\n\nexport const mathValueType = later<JsonInterpolatedType | CoreType | StringType>();\n\nexport const mathOperation = later<JsonInterpolatedType | CoreType | StringType>();\nmathOperation.init(\n  debug(\n    \"mathOperation\",\n    DebugLevel.Info,\n    sequence<JsonInterpolatedType | CoreType | StringType>(\n      [\n        (mathValueType as OneOf<JsonInterpolatedType | CoreType | StringType>).except!(mathOperation),\n        whitespace,\n        oneOf(\n          specificString(\"+\"),\n          specificString(\"-\"),\n          specificString(\"*\"),\n          specificString(\"/\"),\n          specificString(\"%\"),\n          specificString(\"^\")\n        ),\n        whitespace,\n        mathValueType,\n      ],\n      ([left, , operator, , right]) => {\n        return {\n          success: true,\n          type: JsonInterpolatedType.MathOperation,\n          operator: (operator as any).value,\n          left,\n          right,\n        };\n      }\n    )\n  )\n);\n\nexport const mathParensType = later<JsonInterpolatedType | CoreType | StringType>();\nmathParensType.init(\n  sequence(\n    [specificChar(\"(\"), whitespace, mathValueType, whitespace, specificChar(\")\")],\n    ([_open, , expression, , _close]) => {\n      return {\n        ...expression,\n        startToken: _open.startToken,\n        endToken: _close.endToken,\n      };\n    }\n  )\n);\n\nmathValueType.init(oneOf(mathParensType, mathOperation, numberStringValue, variableNameStringValue));\n\nexpressionValueType.init(\n  oneOf(\n    parensExpression,\n    binaryExpression,\n    mathValueType,\n    numberStringValue,\n    booleanStringValue,\n    nullStringValue,\n    undefinedStringValue,\n    variableNameStringValue,\n    stringInQuotes\n  )\n);\n\nexport const interpolatedValue = debug(\n  \"interpolatedValue\",\n  DebugLevel.Info,\n  sequence(\n    [\n      specificString(\"{{\"),\n      whitespace,\n      maybe(spreadOperator),\n      whitespace,\n      many(oneOf(flattenCall)),\n      whitespace,\n      required(\n        oneOf(\n          conditionalStatement,\n          eachStatement,\n          ternaryExpression,\n          nullishCoalescingExpression,\n          comment,\n          binaryExpression,\n          mathValueType,\n          nullStringValue,\n          undefinedStringValue,\n          booleanStringValue,\n          numberStringValue,\n          variableNameStringValue,\n          stringInQuotes\n        ),\n        () => \"Unable to read parse value\"\n      ),\n      whitespace,\n      maybe(comment),\n      whitespace,\n      specificString(\"}}\"),\n    ],\n    ([_introCurly, , spread, , calls, , value, , , , _closeCurly]) => {\n      return {\n        ...value,\n        ...((spread as any).success && (spread as any).value ? { spread: true } : {}),\n        ...((calls as any).success && ((calls as any).value ?? []).length > 0\n          ? { modifiers: (calls as any).value }\n          : {}),\n        startToken: _introCurly.startToken,\n        endToken: _closeCurly.endToken,\n      };\n    }\n  )\n);\n\nexport const interpolatedStringLiteral = debug(\n  \"interpolatedStringLiteral\",\n  DebugLevel.Info,\n  sequence(\n    [\n      match(TokenType.StringLiteralStart),\n      required(\n        many(oneOf(interpolatedValue, stringUntil(\"{{\"))),\n        () => \"match interpolated values or strings which don't match {{\"\n      ),\n      required(match(TokenType.StringLiteralEnd), () => \"Strings must end with an end token\"),\n    ],\n    ([arrayStart, chars, arrayEnd]) => ({\n      type: JsonInterpolatedType.InterpolatedValue,\n      success: true,\n      startToken: arrayStart.startToken,\n      endToken: arrayEnd.endToken,\n      value: (chars as any).children,\n      spread: ((chars as any).children ?? []).some((v: any) => v.spread) ? true : undefined,\n    })\n  )\n);\n\nexport const templateStringLiteral = debug(\n  \"templateStringLiteral\",\n  DebugLevel.Info,\n  sequence<JsonInterpolatedType | StringType | CoreType>(\n    [\n      match(TokenType.StringLiteralStart),\n      required(\n        many(\n          oneOf(debug(\"value\", DebugLevel.Info, interpolatedValue), debug(\"str\", DebugLevel.Info, stringUntil(\"{{\")))\n        ),\n        () => \"match interpolated values or strings which don't match {{\"\n      ),\n      required(match(TokenType.StringLiteralEnd), () => \"Strings must end with an end token\"),\n    ],\n    ([arrayStart, chars, arrayEnd]) => {\n      const spread = ((chars as any).children ?? []).some((v: any) => v.spread) ? true : undefined;\n      const value = (chars as any).children;\n      return {\n        type: JsonInterpolatedType.TemplateString,\n        success: true,\n        startToken: arrayStart.startToken,\n        endToken: arrayEnd.endToken,\n        value,\n        spread,\n      };\n    }\n  )\n);\n\nexport const objectEntry = debug(\n  \"objectEntry\",\n  DebugLevel.Info,\n  sequence(\n    [\n      match(TokenType.ObjectEntryStart),\n      required(match(TokenType.ObjectKeyStart), () => \"Object entry must contain a key\"),\n      required(templateStringLiteral, () => \"Object entry key must contain a string literal\"),\n      required(match(TokenType.ObjectKeyEnd), () => \"Object entry key must end with a key end token\"),\n      required(match(TokenType.ValueStart), () => \"Object entry must contain a value\"),\n      valueType,\n      required(match(TokenType.ValueEnd), () => \"Object entry must end with a value end token\"),\n      required(match(TokenType.ObjectEntryEnd), () => \"Object entry must end with an entry end token\"),\n    ],\n    ([entryStart, _keyStart, key, _keyEnd, _valueStart, value, _valueEnd, entryEnd]) => ({\n      type: JsonInterpolatedType.Property,\n      success: true,\n      startToken: entryStart.startToken,\n      endToken: entryEnd.endToken,\n      key: { ...key, isKey: true },\n      value,\n    })\n  )\n);\n\nexport const object = debug(\n  \"object\",\n  DebugLevel.Info,\n  sequence<JsonInterpolatedType | StringType | CoreType>(\n    [\n      match(TokenType.ObjectStart),\n      required(many(objectEntry), () => \"Objects may only contain object entries\"),\n      required(match(TokenType.ObjectEnd), () => \"Objects must end with an object end token\"),\n    ],\n    ([objectStart, objectEntries, objectEnd]) => ({\n      type: JsonInterpolatedType.Object,\n      success: true,\n      startToken: objectStart.startToken,\n      endToken: objectEnd.endToken,\n      entries: (objectEntries as any).value,\n    })\n  )\n);\n\nvalueType.init(\n  required(\n    oneOf<JsonInterpolatedType | StringType | CoreType>(\n      templateStringLiteral,\n      numberLiteral,\n      booleanLiteral,\n      nullLiteral,\n      array,\n      object\n    ),\n    () => \"Expected one of a template string, number, boolean, null, array or object\"\n  )\n);\n\ntype ValueOptionsModifiers = { type: \"flatten\" }[];\ntype ValueOptions = {\n  params: Record<string, any>;\n  spread?: boolean;\n  isComment?: boolean;\n  each?: {\n    from: any;\n    to: string;\n    condition?: any;\n  };\n  conditionStatus?: boolean;\n  modifiers?: ValueOptionsModifiers;\n};\n\nexport class UndefinedValueError extends Error {\n  constructor(public readonly path: string[]) {\n    super(\n      `Unable to read key '${path[path.length - 1]}' on undefined value: ${path.slice(0, path.length - 1).join(\".\")}`\n    );\n  }\n}\n\nconst resolveVariable = (variablePath: string[], params: Record<string, any>): any => {\n  let current: any = params;\n  for (let i = 0; i < variablePath.length; i++) {\n    const part = variablePath[i];\n    const usedPart = part.replace(/\\?$/, \"\");\n    const currRoot = usedPart.length !== part.length ? current ?? {} : current;\n    if (currRoot === undefined) {\n      throw new UndefinedValueError(variablePath.slice(0, i + 1));\n    }\n    current = current[usedPart];\n  }\n  return current;\n};\n\nconst applyModifiers = (value: any, modifiers: { type: \"flatten\" }[]): any => {\n  if (!modifiers) return value;\n  let current = value;\n  modifiers.forEach((modifier) => {\n    switch (modifier.type) {\n      case \"flatten\":\n        if (!Array.isArray(current)) {\n          throw new Error(`Unable to flatten non-array value ${JSON.stringify(current)}`);\n        }\n        current = current.flat();\n        break;\n      default:\n        throw new Error(`Unknown modifier type ${modifier.type}`);\n    }\n  });\n  return current;\n};\n\nconst _jsonInterpolatedASTToValue = (ast: any, params: Record<string, any>): [val: any, options: ValueOptions] => {\n  try {\n    if (\n      typeof ast === \"string\" ||\n      typeof ast === \"number\" ||\n      typeof ast === \"boolean\" ||\n      ast === null ||\n      ast === undefined\n    ) {\n      return [ast, { params }];\n    }\n\n    let defaultOptions: ValueOptions = {\n      params,\n      spread: ast.spread,\n      modifiers:\n        ast.modifiers && ast.modifiers.length > 0\n          ? ast.modifiers.map((modifier: any) => {\n              if (modifier.type === JsonInterpolatedType.Flatten) {\n                return { type: \"flatten\" };\n              } else {\n                throw new Error(`Unknown modifier type ${modifier.type}`);\n              }\n            })\n          : undefined,\n    };\n\n    switch (ast.type) {\n      case JsonInterpolatedType.Object: {\n        let obj: Record<string, any> | any = {};\n        let earlyResponse: [any, ValueOptions] | undefined = undefined;\n\n        // flatten in a key turns the object into an array\n        // flatten in a value turns the value into an array\n\n        ast.entries.forEach((entry: any) => {\n          if (earlyResponse) return;\n\n          const [key, keyOptions] = _jsonInterpolatedASTToValue(entry.key, params);\n          const filtedKeyModifiers = (keyOptions?.modifiers ?? []).filter((m) => m.type === \"flatten\");\n          if (keyOptions.conditionStatus === true) {\n            let [conditionVal] = _jsonInterpolatedASTToValue(entry.value, { ...keyOptions.params });\n            earlyResponse = [conditionVal, { params, spread: keyOptions.spread }];\n            return;\n          } else if (keyOptions.conditionStatus === false) {\n            return;\n          }\n\n          let value: any;\n          if (keyOptions.each) {\n            const { from, to, condition } = keyOptions.each;\n            value = [];\n\n            from.forEach((v: any) => {\n              const innerParams = { ...params, [to[0]]: v };\n              if (!condition?.expression || jsonInterpolatedASTToValue(condition.expression, { ...innerParams })) {\n                value.push(jsonInterpolatedASTToValue(entry.value, { ...innerParams }));\n              }\n            });\n\n            earlyResponse = [applyModifiers(value, filtedKeyModifiers), { params, spread: keyOptions.spread }];\n            return;\n          } else {\n            // key can modify params\n            [value] = _jsonInterpolatedASTToValue(entry.value, { ...keyOptions.params });\n          }\n\n          value = applyModifiers(value, filtedKeyModifiers);\n\n          if (keyOptions.spread && !keyOptions.isComment) {\n            earlyResponse = [value, { params, spread: keyOptions.spread }];\n          } else if (keyOptions.isComment && keyOptions.spread) {\n            if (Array.isArray(value)) {\n              if (Object.keys(obj).length > 0) {\n                throw new Error(\"Unable to spread array after object keys\");\n              }\n              if (!Array.isArray(obj)) {\n                obj = [];\n              }\n              obj = [...obj, ...value];\n            } else {\n              if (Array.isArray(obj)) {\n                throw new Error(\"Unable to spread object after array\");\n              }\n              obj = { ...obj, ...value };\n            }\n          } else {\n            if (Array.isArray(obj)) {\n              throw new Error(\"Unable to set object keys after a spread\");\n            }\n            obj[key] = value;\n          }\n        });\n\n        return earlyResponse ?? [obj, { ...defaultOptions, params }];\n      }\n      case JsonInterpolatedType.Comment:\n        return [undefined, { ...defaultOptions, isComment: true, params }];\n      case JsonInterpolatedType.Array: {\n        const arr: any[] = [];\n        ast.value.forEach((entry: any) => {\n          const [value, valueOptions] = _jsonInterpolatedASTToValue(entry, params);\n          if (valueOptions.spread) {\n            arr.push(...value);\n          } else {\n            arr.push(value);\n          }\n        });\n        return [arr, { ...defaultOptions, params }];\n      }\n      case JsonInterpolatedType.MathOperation: {\n        const [left, leftOptions] = _jsonInterpolatedASTToValue(ast.left, params);\n        const [right] = _jsonInterpolatedASTToValue(ast.right, { ...leftOptions.params });\n        switch (ast.operator) {\n          case \"+\":\n            return [left + right, { ...defaultOptions, params }];\n          case \"-\":\n            return [left - right, { ...defaultOptions, params }];\n          case \"*\":\n            return [left * right, { ...defaultOptions, params }];\n          case \"/\":\n            return [left / right, { ...defaultOptions, params }];\n          case \"%\":\n            return [left % right, { ...defaultOptions, params }];\n          case \"^\":\n            return [left ** right, { ...defaultOptions, params }];\n          default:\n            throw new Error(`Unknown operator ${ast.operator}`);\n        }\n      }\n      case JsonInterpolatedType.EachStatement: {\n        const { from, to, condition } = ast;\n        let iter = resolveVariable(from.value, params);\n        let iterArr = Array.isArray(iter) ? iter : [iter];\n\n        // throw new Error(\"Not implemented\");\n\n        return [undefined, { ...defaultOptions, params, each: { from: iterArr, to: to.value, condition } }];\n      }\n      case JsonInterpolatedType.TernaryExpression: {\n        const { condition, trueValue, falseValue } = ast;\n        const response = _jsonInterpolatedASTToValue(condition, params)[0]\n          ? _jsonInterpolatedASTToValue(trueValue, params)\n          : _jsonInterpolatedASTToValue(falseValue, params);\n        return [response[0], { ...defaultOptions, params }];\n      }\n      case JsonInterpolatedType.NullishCoalescingExpression: {\n        const { left, right } = ast;\n        try {\n          const leftVal = _jsonInterpolatedASTToValue(left, params);\n          if (typeof leftVal[0] !== \"undefined\" && leftVal[0] !== null) {\n            return leftVal;\n          }\n        } catch (e) {\n          if (!(e instanceof UndefinedValueError)) {\n            throw e;\n          }\n        }\n        const response = _jsonInterpolatedASTToValue(right, params);\n        return [response[0], { ...defaultOptions, params }];\n      }\n      case JsonInterpolatedType.ConditionalStatement: {\n        const { statement } = ast;\n        if (statement.expression) {\n          if (_jsonInterpolatedASTToValue(statement.expression, params)[0]) {\n            return [undefined, { ...defaultOptions, params, conditionStatus: true }];\n          } else {\n            return [undefined, { ...defaultOptions, params, conditionStatus: false }];\n          }\n        } else {\n          return [undefined, { ...defaultOptions, params, conditionStatus: true }];\n        }\n      }\n      case JsonInterpolatedType.BinaryExpression: {\n        const { left, right, operator } = ast;\n        const [leftVal] = _jsonInterpolatedASTToValue(left, params);\n        const [rightVal] = _jsonInterpolatedASTToValue(right, params);\n        switch (operator) {\n          case \"===\":\n            return [leftVal === rightVal, { ...defaultOptions, params }];\n          case \"!==\":\n            return [leftVal !== rightVal, { ...defaultOptions, params }];\n          case \"==\":\n            return [leftVal == rightVal, { ...defaultOptions, params }];\n          case \"!=\":\n            return [leftVal != rightVal, { ...defaultOptions, params }];\n          case \">=\":\n            return [leftVal >= rightVal, { ...defaultOptions, params }];\n          case \"<=\":\n            return [leftVal <= rightVal, { ...defaultOptions, params }];\n          case \">\":\n            return [leftVal > rightVal, { ...defaultOptions, params }];\n          case \"<\":\n            return [leftVal < rightVal, { ...defaultOptions, params }];\n          default:\n            throw new Error(`Unknown operator ${operator}`);\n        }\n      }\n      case JsonInterpolatedType.VariablePath:\n        return [resolveVariable(ast.value, params), { ...defaultOptions, params }];\n      case JsonInterpolatedType.NumberLiteral:\n      case JsonInterpolatedType.BooleanLiteral:\n      case JsonInterpolatedType.NullLiteral:\n      case JsonInterpolatedType.UndefinedLiteral:\n      case StringType.StringLiteral:\n        return [ast.value, { ...defaultOptions, params }];\n      case JsonInterpolatedType.TemplateString: {\n        const allOptions = {\n          ...defaultOptions,\n        };\n        const parts = (Array.isArray(ast.value) ? ast.value : [ast.value]).map((v: any) =>\n          _jsonInterpolatedASTToValue(v, params)\n        );\n\n        if (parts.length === 1 && parts[0][1].spread) {\n          return parts[0];\n          // let [val, options] = parts[0];\n          // return [\n          //   applyModifiers(val, options.modifiers ?? []),\n          //   { ...defaultOptions, ...options, modifiers: undefined },\n          // ];\n        }\n\n        const str = parts\n          .map((p: any, i: number) => {\n            Object.assign(allOptions, p[1]);\n            if (typeof p[0] == \"undefined\" && !params[MagicJsonParams.ConvertUndefinedToNull] && !ast.isKey) {\n              throw new Error(`Undefined value in template string`);\n            }\n\n            if (\n              typeof p[0] !== \"string\" &&\n              typeof p[0] !== \"number\" &&\n              typeof p[0] !== \"boolean\" &&\n              p[0] !== null &&\n              p[0] !== undefined\n            ) {\n              throw new Error(\n                `Unable to stringify value (${i} of ${parts.length}): ${JSON.stringify(p[0])} (${typeof p[0]})`\n              );\n            }\n            return p[0];\n          })\n          .join(\"\");\n        return [str, { ...allOptions, params }];\n      }\n      default:\n        throw new Error(`Unknown type ${ast.type}`);\n    }\n  } catch (e: any) {\n    if (e instanceof UndefinedValueError) {\n      throw e;\n    }\n    if (e instanceof JsonTemplateError) {\n      throw e;\n    }\n    throw new JsonTemplateError(`${ast.type}: ${e.message}`, ast.startToken, ast.endToken);\n  }\n};\n\nexport const jsonInterpolatedASTToValue = (ast: any, params: Record<string, any>): any => {\n  return _jsonInterpolatedASTToValue(ast, params)[0];\n};\n","import ASTBuilder from \"./ast\";\nimport { JsonTemplateError } from \"./combinators/core\";\nimport { interpolatedJson, jsonInterpolatedASTToValue } from \"./combinators/json-interpolation\";\nimport { Parseable, Token, Tokenizer } from \"./tokens\";\n\nclass TemplateError extends Error {\n  constructor(message: string, public readonly context: { cause?: Error }) {\n    super(message);\n  }\n}\n\nfunction truncate(str: string, n: number) {\n  return str.length > n ? str.slice(0, n - 1) + \"...\" : str;\n}\n\nexport const evaluateTemplate = (obj: Parseable, params: Record<string, any>) => {\n  let tokenizer = new Tokenizer();\n  let tokens: Token[] = [],\n    input: Parseable;\n  try {\n    [tokens, input] = tokenizer.toTokens(obj);\n\n    let astBuilder = new ASTBuilder();\n    let ast = astBuilder.generateAST(tokens, interpolatedJson);\n    let response = jsonInterpolatedASTToValue(ast, params);\n    return response;\n  } catch (e: any) {\n    if (e instanceof JsonTemplateError) {\n      if (!e.jsonPath) {\n        console.log(\"e.startToken\", e.startToken, tokens[e.startToken]);\n        e.setPath(tokens[e.startToken].jsonPath);\n      }\n      let [errorNode] = tokenizer.getValueForJsonPath(e.jsonPath!, input!);\n      throw new TemplateError(`Error at ${e.jsonPath?.path.join(\".\")} (${truncate(JSON.stringify(errorNode), 60)}): ${e.message}`, { cause: e });\n    }\n    throw e;\n  }\n};\n"],"names":[],"mappings":"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"}